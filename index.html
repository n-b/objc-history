<!DOCTYPE html>
<html>
  <head>
    <title>Objective-C</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <script src="https://github.com/downloads/gnab/remark/remark-0.4.2.min.js" type="text/javascript">
	{ 
		"highlightLanguage": "objectivec",
		"highlightInline": true,
		"highlightStyle": "solarized_light"
	}
	</script>
	<style type="text/css" media="screen">
	@import url(http://fonts.googleapis.com/css?family=Quattrocento+Sans:400,700);
	@import url(http://fonts.googleapis.com/css?family=Amaranth:700italic);

	h1 {
		font-family: 'Amaranth', sans-serif;
		font-weight: bold;
		font-style: italic;
	}
	body {
		font-family: 'Quattrocento Sans', sans-serif;
	}
	a {
		color: #a86;
		text-decoration: none;
	}
	.position {
		visibility: hidden;
	}
	.footnote {
		position: absolute;
		bottom: 1em;
		left: 1em;
		right: 1em;
	}
	</style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Objective-C Features 
#### Un aperçu historique

.footnote[[github.com/n-b/objc-features](github.com/n-b/objc-features)]

--

*(Partiel et subjectif)*


---

class: center

## C & SmallTalk

--

## Brad Cox & Tom Love
<!--

1980 

Fin 70, début 80, mode de la POO.

* C++ date de 1983
 
-->

--

## Stepwise

--

## gcc

--

## NeXT

--

##### NeXTSTEP, OPENSTEP, GnuStep

--

## Apple

--

## clang


<!--
La responsabilité du langage à évolué.

Pas de standard ISO ou normé, contrairement à C ou C++; pas non plus d'organisme dédié à la normalisation, contrairement à tous les languages. Java avait Sun Perl, ruby a une souce officielle sur ruby-lang, python.org, etc. Objective-C est un des seuls languages a ne pas avoir sa propre homepage.
-->

<!--
L'implémentation originale de Brad Cox était un preprocessor, qui générait du C.
-->

<!--
* Les objets sont compilés C structs
* access ivars with ->
* .h et .m

```
@class, @interface, @protocol, 
@encode
@defs
```

Je me concentre sur la branche principale, de Next à Apple.
-->


---

class: center, middle

# NeXT

<!--
* Next licences objc from Stepstone,
* Buys Objective-C rights in 1995

Début des années 90, le paysage ObjC est très différent de 2012.
-->

*“How much does Stepstone charge for the PC version of Obj-C&nbsp;?<br>And, does it run on a 286&nbsp;?”*

*comp.sys.next.programmer, 1992*

<!--
* NeXTStep n'est pas la seule implémentation ObjC à l'époque, il y a aussi GnuStep.
* NExtStep Enterprise tourne sur d'autres archis, y compris sur NT.
-->

---

class: center, middle

## NeXT OS 4.0, 1994

#### Préfixe `NS`

<!--
Le préfixe des classes Next, "NX", devient NS à la création de Foundation. 

NXApp est renommé NSApp, par exemple.
Surtout, `NSObject` remplace `Object`

-> C'est le split principal entre avec GnuStep, qui continue d'utiliser Object et implémentera petit à petit les méthodes de Foundation.

-->

--
	
*“The Foundation kit release notes describes the new<br>
 **autorelease, retain, release**<br>
  paradigm.”*


---
layout: true

## Next 

---

<!-- la gestion semi-automatique de la mémoire apparait en 1994 -->

### Gestion “Semi-Automatique” de la mémoire

    - (id) retain;
    - (void) release;
    - (id) autorelease;

--
	
Sur GnuStep, les `Object`s ont une méthode `free`, comme en c++.


---

### “Cocoa”

<!--
Les concepts fondamentaux de Cocoa existent déjà. On retrouve ces concepts aujourd'hui encore dans le design de UIKit.
-->

* Interface Builder et AppKit
	* (Xcode s’appelle Project Builder)
* IBOutlets and IBActions
* Target-Action
* Responder Chain

---

## “Enterprise Objects Framework”

<!-- 
Le principal produit de NeXT après l’échec des machines comme le cube, un framework objet orienté Entreprises.

Il va introduire des concepts très importants pour la suite
-->

--

* Key-Value Coding via le protocole `EOFKeyValueCoding`

	- (void) valueForKey:(NSString*)key;
	- (void) setValue:(id)value forKey:(NSString*)key;
	
<!-- 
Strictement, ce n'est pas une partie du langage, même s'il utilise les accès bas-niveau du Runtime.
A l’époque, la question ne se pose d’ailleurs pas, ce sont des méthodes de EOF, pas du langage.
-->

--

* WebObjects

<!--
Le serveur d'entreprise d’Apple, et surtout
-->
--

* Coredata

<!--
qui apparaitra plus tard, mais qui reprend exactement la même idée.
-->

---

## Distributed Objects

<!--
Aujourd'hui plus ou moins abandonné, mais qui permet à l'époque de faire des envois de message (au sens objc) entre process, et sur le réseau.
XPC ?
-->

<!-- syntaxe quasiment plus utilisée nulle part -- >

Type Qualifiers
  
	oneway
	in
	out
	inout
	bycopy
	byref

&nbsp;

	- (oneway void) doSomethingInRemoteObject;

---

### Dynamic Loading

<!-- Le chargement dynamique de classes est une feature du runtime -->

	`objc_loadmodule`

&nbsp;

    [NSBundle bundleForClass:]


---

### Foundation

<!-- Foundation apporte aussi un lot de méthodes pour faciliter la manipulation bas niveau, et le forward d'invocation -->

* NSSelectorFromString, NSClassFromString, etc.
* NSInvocation
* NSProxy 

<!-- le forward est plus ou moins vu comme un palliatif à l'absence d'héritage multiple. En tout les cas, c'est un mécanisme de POO qui est permit par des objets NS.
-->
	
---

### Style

<!--
Le style évolue aussi, la plupart des méthodes retourne "self" au lieu de "void".
 -->


	@inteface SomeClass

	- (id) doThis;
	- (id) doThat;

	@end

--
	
	...
	
	[[someObject doThis] doThat];

---

### Style

<!-- 
(id) is !still! the default type for methods and args, you can write 
-->

	@inteface SomeClass

	- method: arg;

	@end

--
	
	@implementation MyClass

	- method: arg
	{
	    return someObject;
	}

	@end


---
layout:true
class: center, middle

# Apple

---

Rachat de Next en 1997

---

*“Cocoa is owned by Apple, and the indications are that Apple is going to either completely drop its support for ObjC in favor of Java, or at least de-emphasize its use to the point where nobody would want to even look at it (in fact, this "death by default" has already happened).”*

comp.sys.next.programmer, Avril 2000.

<!--
Apple a effectivement d'autres plans pour Mac OS X. (ou plutôt des alternatives).

-->

---

Carbon et CoreFoundation

--

JavaCocoa

<!-- JavaCocoa n'est un bridge pour faire de l'objc en Cocoa, mais un bridge Cocoa pour Java, qui permet d'utiliser AppKit en Java.
A l'époque, Apple vante Mac OS X comme "le premier système compatible Java".

(En tout cas pour le développement d'applications desktop)

Il faut admettre qu'en 2000, Java est considéré comme le future de l'informatique.

Peu d’applis sont réellement développées avec JavaCocoa. Cyberduck.
-->

---

layout: true

# Apple

---

## Toll-Free Bridging (Mac OS X 10.0)

<!-- Compatibilité avec CoreFoundation pour simplifier l'adoption de Mac OS X -->


	NSString * <=> CFStringRef

--

<!--
Pas strictement un ajout à objc, mais implémenté avec un hack dans le language
-->

`objc_getfutureclass`&nbsp;: Used by CoreFoundation's toll-free bridging. Do not call this function yourself.


---
layout: true
## Mac OS X 10.3

---

### Key-Value Observing et Bindings

<!-- basé sur les conventions du KVC, permet d'être notifié d'un changement de valeur d'un objet.-->

	[object addObserver:self forKeyPath:@"someKey" options:0 context:NULL];
<!-- apporte aussi nombre de conventions de nommage, il s'agit des prémices des @properties-->

--
<!-- Implémenté avec un hack lui aussi, qui insère une classe dans la hiérarchie au moment ou on commence à observer un objet. -->

`objc_duplicateclass`&nbsp;: Used by Foundation's Key-Value Observing. Do not call this function yourself.

---

## Exceptions modernes

--

<!-- le vieux mécanisme d'exception utilise setjmp/longjmp, c'est à dire un saut (brutal) sur la stack -->
<!-- implémenté avec des macros -->

	NS_DURING
		[[NSException exception] raise];
	NS_HANDLER
	   // handle it
	NS_ENDHANDLER

--

<!-- Le nouveau mécanisme est le même que C++ (et il est compatible avec lui), permet par exemple de récupérer la stack. -->

	@try
		@throw exception
	@catch
		// handle it
	@finally


---

layout:true
## Mac OS X 10.4

<!-- switch (back) to Intel, mais a priori ce n'est pas ce qui pose de problème à ObjC. -->

### CoreData

<!-- Héritier de EOF -->

--

### Key-Value Coding sur les Collections

	[array valueForKey:@"someValue"]

<!-- retourne un array en appelant valueForKey: sur chaque objet de la collection -->

--

### Opérateurs de collection

<!-- Programmation de plus haut niveau, metaprog -->

	[persons valueForKeyPath:@"@avg.age"];
	[array valueForKey:@"someValue"]
	

---

layout: false
class: center, middle

# Mac OS X 10.5
# Objective-C 2.0

---

layout:true
## Objective-C 2.0

---

### Garbage Collector

*“State of the art”*

<!--
Apple en est très fière. Cependant, il faut compiler en double, on ne peut linker qu'avec des frameworks compatibles avec le GC.

Même s'il finira par être abandonné, il aide à clarifier les notions de gestion de mémoire, de graphe d'objets.
(de responsabilité et d'appartenance). On commence à parler de pointeurs strong et weak.
-->

--- 

### Properties

Notation pointée

<!--
Compatible avec les properties, mais avec tout ce qui respecte le nommage KVC.
-->

	[obj setFoo:value]

devient

	obj.foo = value;

--

	- (Foo*) foo;
	- (void) setFoo:(Foo*)foo;
	
devient

	@property Foo* foo;


<!-- On ajoute une nouvelle syntaxe pour des taches existantes. -->
<!-- ne fait pas l'unanimité chez les vétérans, parce qu'on a l'impression de manipuler des structs C.-->

---

### Fast Enumeration

<!-- si vous n'avez pas fait d'objc avant 10.5, vous n'avez pas idée de ce que c'était.-->
<!-- Autant la notation pointée est accueille avec certaines réserves, autant tout le monde accueille ça avec soulagement-->

--
	
	NSEnumerator * e
	
    NSEnumerator * enumerator = [array objectEnumerator];
    NSObject * object = nil;
	
    while ( (object = [enumerator nextObject]) != nil )
	{
        ...
    }
	
--

	for( NSObject* object in array)
	{
		...
	}

---
### "Modern runtime"

Uniquement sur Mac 64-bit et sur iOS.

**Non-fragile ABI**

<!--
	ajout d'ivar au runtime
	Object != struct
	Une nouvelle version d'une classe parente ne casse pas les classes filles.
-->

--
@defs et sizeof(NSArray) n’ont plus de sens.

---

### Bonus d’Objective-C 2.0


`NS_REQUIRES_NIL_TERMINATION`

-- 

NSZones deprecated

<!--
Permet d'allouer un objet dans une zone mémoire prédéfinie. N'avait plus vraiment de sens depuis longtemps. Nécessaire pour le GC.
-->

--

Bridges du runtime avec d’autres languages : rubyCocoa, python (pyObjC), AppleScript…
<!--n'utilisent pas la syntaxe d'objc, mais utilisent directement le runtime pour utiliser des méthodes Cocoa ou ObjC. -->

--

JavaCocoa deprecated.

<!-- At last !-->

--

`@optional` methods in Protocols.

<!-- l'ancienne notion de "protocol informel", implémenté avec une catégorie sur NSObject, disparait. -->

--

Class Extentions ("catégorie anonyme")
	
	// Class.m
	@interface Class(PrivateMethods)
	...
	@end
	
devient

	// Class.m
	@interface Class()
	...
	@end
	
<!--
 Le principal est que le compilateur sait qu'une méthode privée manque de l'implémentation.
 Ici aussi, on ajoute une nouvelle syntaxe pour un usage courant.
-->

---

layout:false
class: center,middle

# clang

<!-- la grosse évolution suivante est le changement de compilateur, qui va permettre à Apple d'ajouter toutes les features à son rythme, sans dépendre de gcc.-->

---

## Xcode 3

Clang static analyzer


<!--
Détecte les leaks à la compilation en se basant sur les conventions du language.
-->


---

## Blocks (“Objective-C 2.1”)

	__block BOOL found = NO;
	NSSet *aSet = [NSSet setWithObjects: @"Alpha", @"Beta", @"Gamma", @"X", nil];
	NSString *string = @"gamma";
 
	[aSet enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
	    if ([obj localizedCaseInsensitiveCompare:string] == NSOrderedSame) {
	        *stop = YES;
	        found = YES;
	    }
	}];
 
	// At this point, found == YES

<!--
Ajout à C, autant qu’à ObjC. On peut utiliser les blocks sans objective-C, mais la structure interne des blocks est compatible avec les objets ObjC (on peut par exemple les mettre dans un NSArray.)

Gros, gros changement de paradigme. Remplace dans certaines API les delegates, les selecteurs, etc.
Concept similaire aux NSInvocations, dans l'absolu.

D'un autre côté, la syntaxe n'est pas géniale, et le flag de termination dans l'exemple est franchement inélégant.
-->

---

## iOS 4.2

* Macros de weak linking (NS_CLASS_AVAILABLE)

---

## iOS 5

* `UIAPPEARANCE_SELECTOR`

---
layout:true
## LLVM Compiler 3.0

---

#### Private Instance Variables

<!--
	sucre syntaxique qui ne fait au font qu'utiliser les fonctionnalités du runtime moderne
	* no forward declaration of methods needed anymore (LLVM Compiler 3.1)
-->

	// MyClass.h
	@interface MyClass : NSObject
	{
		int foo;
		id bar;
	}
	...
	@end

devient

	// MyClass.m
	@interface MyClass ()
	{
		int foo;
		id bar;
	}
	...
	@end


---

#### Private Instance Variables

<!--
	sucre syntaxique qui ne fait au font qu'utiliser les fonctionnalités du runtime moderne
	* no forward declaration of methods needed anymore (LLVM Compiler 3.1)
-->

	// MyClass.h
	@interface MyClass : NSObject
	{
		int foo;
		id bar;
	}
	...
	@end

ou même

	@implementation MyClass
	{
		int foo;
		id bar;
	}
	...
	@end


---

<!-- Même si elle n'a pas (encore) de features privées, Apple utilise son propre fork de clang, et n'utilise pas la même numérotation de versions. -->
#### ARC

--

<!-- le but va être de remplacer le GC -->
Garbage Collector deprecated

--

`retain` et `release` sont intégrés au language.

<!--
jusque là, c'était encore un mécanisme fait par Foundation, indépendant du runtime ou du compilateur.
retain et release deviennent partie du language, on n'a plus le droit de les réimplémenter ou de les appeler manuellement.
glissement sémantique : les attributs assign/retain des properties deviennent weak/strong.
-->

--

`objc_method_family`

<!-- Certaines méthodes sont automatiquement reconnues comme ayant une sémantique particulière, par exemple les méthodes alloc et new qui créent un objet avec un retain count à 1. 
La famille de méthode peut-être définie automatiquement, en respectant les conventions que clang connait, ou en précisant un attribut à la main
-->

-- 

weak pointers

<!-- Automatiquement mis à nil quand l'objet pointé est détruit. (à partir de iOS 5 et 10.8) -->


---
layout:true
## LLVM Compiler 4.0

---

#### `@synthesis` automatique des ivars des properties
<!-- sauf pour NSManagedObject. En fait, clang l'avait intégré pour Xcode 4.0b, et était revenu au design parce que la première version gérait mal certains cas. -->

---

#### Boxing
	
	[NSNumber numberWithDouble:M_PI/2.0]
	
devient
	
	@(M_PI/2.0)

---

#### Container literals

pour `NSArray` et `NSDictionary

	[NSArray arrayWithObject:obj1, obj2, obj3, nil];
	
devient
	
	@[obj1, obj2, obj3]

---

#### Subscripting

	[dictionary objectForKey:@"key"];
	
devient

	dictionary[@"key"]

<!--
 Pas forcément super clair qu'il ne s'agit pas d'un array C. 
 Implémentation appelle en réalité de nouvelles méthodes (indexedObjectForKey), qui doivent être définies sur le container.
 On peut les ajouter à ses propres classe si on veut et les rendres compatibles avec le subscripting. C'est presque de l'overload d'opérateur à la c++.
-->

---
#### Bonus

Mot clé `instancetype`

<!-- implémenté avec les objc_method_family -->

	@interface A
	+ (instancetype)constructAnA;
	@end

--

<!-- permet au compilateur de savoir que [NSMutableArray new] renvoie un NSMutableArray, pas un NSArray, ni un id -->

	[[NSMutableArray new] addObject:someObject];


--

Function Overloading in C

	float __attribute__((overloadable)) tgsin(float x) { return sinf(x); }
	double __attribute__((overloadable)) tgsin(double x) { return sin(x); }
	long double __attribute__((overloadable)) tgsin(long double x) { return sinl(x); }
	
--

CoreFoundation “compatible” avec ARC : `arc_cf_code_audited`.

<!-- simplifie le bridge, et permet d'utiliser les conventions de nommage de CF avec ARC.-->

---
layout: true

# Futur ?

---

<!-- ma wishlist, en quelque sorte. -->

* Appel à `super` automatique (sans spécifier les arguments)

--

`-[NSString stringWithFormat:]` plus court

--

Boxing pour NSValue

	[NSValue valueWithCGPoint:CGPointMake(10,20)];

	@( CGPointMake(10,20) )
	
<!--
En réalité, il y a déjà un système de wrapping pour les structs, avec le KVC : 
 "The default implementations of valueForKey: and setValue:forKey: provide support for automatic object wrapping of the non-object data types, both scalars and structs." 
-->

--

* namespaces

---

Un attribut de méthode pour le *designated initializer*
<!-- il n'y a aujourd'hui rien qui vérifie que les règles d'appel du DI sont respectées par ses subclasses.-->

--

Méthodes protected et marquées pour réimplémentation

<!--
 ça doit faire 20 ans qu'on le demande pour les protected
 Certaines API déclarent certaines méthode uniquement pour être réimplémentées, par ex -drawRect:. 
 Ça ne sert à rien qu'elle soit déclarée comme le reste de l'API de UIView.
 -->

--

Valeurs de paramètres par défaut 
<!--
 Ce style d'API est super commun, et à chaque fois, c'est la doc qui précise quelle est la valeur des arguments ignorées.
 Ça serait mieux dans le language.
-->

	- (void) doSomething;
	- (void) doSomethingWithStuff:(Stuff*)s;


---
layout:false
class:center

# Links

[comp.sys.next.programmer](https://groups.google.com/forum/?fromgroups=#!topic/comp.sys.next.programmer/NUXThBOc360)
[Objective-C Feature Availability Index]http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/ObjCAvailabilityIndex/_index.html
<br>
<br>
[The OPENSTEP Development Environment](http://objc.toodarkpark.net/introobj.html#712)
[MacTECH : C++ Versus Objective-C](http://www.mactech.com/articles/mactech/Vol.13/13.03/CandObjectiveCCompared/index.html)
[GnuStep ObjectiveC Book](http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf)
[History of Cocoa and Objective-C](http://www.cocoacast.com/cocoacast/?q=node/14)
[Objective-C Runtime Reference](http://developer.apple.com/library/ios/ipad/#documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html)
[Clang Language Extensions](http://clang.llvm.org/docs/LanguageExtensions.html#objc_features)


</textarea><div id="slideshow"></div></body></html>
